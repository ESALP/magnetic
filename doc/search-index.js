var searchIndex = {};
searchIndex['magnetic'] = {"items":[[0,"buffer","magnetic","Memory buffer API",null,null],[0,"dynamic","magnetic::buffer","Buffer which is allocated at run time",null,null],[3,"DynamicBuffer","magnetic::buffer::dynamic","Holds data allocated from the heap at run time",null,null],[3,"DynamicBufferP2","","Holds data allocated from the heap at run time. Similar to `DynamicBuffer`\nexcept that the size must be a power of two. This will result in slightly\nfaster runtime performance due to the use of a mask instead of modulus\nwhen computing buffer indexes.",null,null],[11,"new","","Create a new `DynamicBuffer` of the given size. This method will\nreturn an error if the requested number of bytes could not be\nallocated.",0,{"inputs":[{"name":"dynamicbuffer"},{"name":"usize"}],"output":{"name":"result"}}],[11,"drop","","",0,{"inputs":[{"name":"dynamicbuffer"}],"output":null}],[11,"size","","",0,{"inputs":[{"name":"dynamicbuffer"}],"output":{"name":"usize"}}],[11,"at","","",0,null],[11,"at_mut","","",0,null],[11,"new","","Create a new `DynamicBufferP2` of the given size. This method will\nreturn an error if the requested number of bytes could not be\nallocated or size is not a power of two.",1,{"inputs":[{"name":"dynamicbufferp2"},{"name":"usize"}],"output":{"name":"result"}}],[11,"drop","","",1,{"inputs":[{"name":"dynamicbufferp2"}],"output":null}],[11,"size","","",1,{"inputs":[{"name":"dynamicbufferp2"}],"output":{"name":"usize"}}],[11,"at","","",1,null],[11,"at_mut","","",1,null],[8,"Buffer","magnetic::buffer","All buffers must implement this trait to be used with any of the queues.",null,null],[10,"size","","Return the size of the buffer",2,{"inputs":[{"name":"buffer"}],"output":{"name":"usize"}}],[10,"at","","Return a pointer to data at the given index. It is expected that this\nfunction use modular arithmetic since `idx` may refer to a location\nbeyond the end of the buffer.",2,null],[10,"at_mut","","Return a mutable pointer to data at the given index. It is expected\nthat this function use modular arithmetic since `idx` may refer to a\nlocation beyond the end of the buffer.",2,null],[0,"spsc","magnetic","Single-producer single-consumer queue",null,null],[3,"SPSCConsumer","magnetic::spsc","Consumer end of the queue. Implements the trait `Consumer<T>`.",null,null],[3,"SPSCProducer","","Producer end of the queue. Implements the trait `Producer<T>`.",null,null],[5,"spsc_queue","","Creates a new SPSC queue",null,null],[11,"push","","",3,{"inputs":[{"name":"spscproducer"},{"name":"t"}],"output":null}],[11,"try_push","","",3,{"inputs":[{"name":"spscproducer"},{"name":"t"}],"output":{"name":"option"}}],[11,"pop","","",4,{"inputs":[{"name":"spscconsumer"}],"output":{"name":"t"}}],[11,"try_pop","","",4,{"inputs":[{"name":"spscconsumer"}],"output":{"name":"option"}}],[0,"mpsc","magnetic","Multiple-producer single-consumer queue",null,null],[3,"MPSCConsumer","magnetic::mpsc","Consumer end of the queue. Implements the trait `Consumer<T>`.",null,null],[3,"MPSCProducer","","Producer end of the queue. Implements the trait `Producer<T>`.",null,null],[5,"mpsc_queue","","Creates a new MPSC queue",null,null],[11,"push","","",5,{"inputs":[{"name":"mpscproducer"},{"name":"t"}],"output":null}],[11,"try_push","","",5,{"inputs":[{"name":"mpscproducer"},{"name":"t"}],"output":{"name":"option"}}],[11,"pop","","",6,{"inputs":[{"name":"mpscconsumer"}],"output":{"name":"t"}}],[11,"try_pop","","",6,{"inputs":[{"name":"mpscconsumer"}],"output":{"name":"option"}}],[0,"spmc","magnetic","Single-producer multiple-consumer queue",null,null],[3,"SPMCConsumer","magnetic::spmc","Consumer end of the queue. Implements the trait `Consumer<T>`.",null,null],[3,"SPMCProducer","","Producer end of the queue. Implements the trait `Producer<T>`.",null,null],[5,"spmc_queue","","Creates a new SPMC queue",null,null],[11,"push","","",7,{"inputs":[{"name":"spmcproducer"},{"name":"t"}],"output":null}],[11,"try_push","","",7,{"inputs":[{"name":"spmcproducer"},{"name":"t"}],"output":{"name":"option"}}],[11,"pop","","",8,{"inputs":[{"name":"spmcconsumer"}],"output":{"name":"t"}}],[11,"try_pop","","",8,{"inputs":[{"name":"spmcconsumer"}],"output":{"name":"option"}}],[0,"mpmc","magnetic","Multiple-producer multiple-consumer queue",null,null],[3,"MPMCConsumer","magnetic::mpmc","Consumer end of the queue. Implements the trait `Consumer<T>`.",null,null],[3,"MPMCProducer","","Producer end of the queue. Implements the trait `Producer<T>`.",null,null],[5,"mpmc_queue","","Creates a new MPMC queue",null,null],[11,"push","","",9,{"inputs":[{"name":"mpmcproducer"},{"name":"t"}],"output":null}],[11,"try_push","","",9,{"inputs":[{"name":"mpmcproducer"},{"name":"t"}],"output":{"name":"option"}}],[11,"pop","","",10,{"inputs":[{"name":"mpmcconsumer"}],"output":{"name":"t"}}],[11,"try_pop","","",10,{"inputs":[{"name":"mpmcconsumer"}],"output":{"name":"option"}}],[8,"Producer","magnetic","The consumer end of the queue allows for sending data. `Producer<T>` is\nalways `Send`, but is only `Sync` for multi-producer (MPSC, MPMC) queues.",null,null],[10,"push","","Add value to front of the queue. This method will block if the queue\nis currently full.",11,{"inputs":[{"name":"producer"},{"name":"t"}],"output":null}],[10,"try_push","","Attempt to add a value to the front of the queue. If the value was\nadded successfully, `None` will be returned. If unsuccessful, `value`\nwill be returned. An unsuccessful push indicates that the queue was\nfull.",11,{"inputs":[{"name":"producer"},{"name":"t"}],"output":{"name":"option"}}],[8,"Consumer","","The consumer end of the queue allows for receiving data. `Consumer<T>` is\nalways `Send`, but is only `Sync` for multi-consumer (SPMC, MPMC) queues.",null,null],[10,"pop","","Remove value from the end of the queue. This method will block if the\nqueue is currently empty.",12,{"inputs":[{"name":"consumer"}],"output":{"name":"t"}}],[10,"try_pop","","Attempt to remove a value from the end of the queue. If the value was\nremoved successfully, `Some(T)` will be returned. If unsuccessful,\n`None` will be returned. An unsuccessful pop indicates that the queue\nwas empty.",12,{"inputs":[{"name":"consumer"}],"output":{"name":"option"}}]],"paths":[[3,"DynamicBuffer"],[3,"DynamicBufferP2"],[8,"Buffer"],[3,"SPSCProducer"],[3,"SPSCConsumer"],[3,"MPSCProducer"],[3,"MPSCConsumer"],[3,"SPMCProducer"],[3,"SPMCConsumer"],[3,"MPMCProducer"],[3,"MPMCConsumer"],[8,"Producer"],[8,"Consumer"]]};
initSearch(searchIndex);
